# Estado del contrato
Cuando creamos un contrato, generalmente tendremos algunas propiedades que queremos tener definidas que pueden tener un estado y que lógicamente tenemos que poder modificar. Este estado puede tener diversa información: si deployamos un token, parte del estado puede ser la url donde se encuentra el logo de nuestro token, pasando por la cantidad de tokens emitidos que hay o cuántas unidades de nuestro token tiene cada usuario. 

Este estado, se modifica a través de transacciones que el usuario tendrá que pagar utilizando NEAR. Al mismo tiempo, nosotros podemos elegir agregar un costo extra para poder llamar a la función, si fuera por ejemplo que se tiene que pagar por almacenamiento o quizá queremos que represente un registro a nuestro sitio y queremos que tenga un costo. 

## yocto
El yocto forma parte del sistema de unidades. De la misma manera que nos referimos a `mili` como en milímetros o milisegundos para referirnos a la unidad 10^-3 o `micro` para referirnos a 10^-6, yocto se refiere a 10^-24. Es decir, la potencia concuerda con los decimales que tiene el token NEAR. Es decir, 1 NEAR=10^24 yoctoNear. 

### ¿De qué me sirve?
En la red de NEAR, existen distintos tipos de claves con las que se puede firmar una transacción. Si una función que modifica el estado del contrato no requiere ningún pago, es posible configurar la aplicación para que no se requiera que el usuario reconfirme la transacción que se está haciendo. Esto es potencialmente peligroso porque si nos conectamos a un sitio malicioso y tenemos una función que no requiere pago, el atacante podría hacernos llamar a dicha función sin que nos enteremos. Podría ser potencialmente peligroso si, por ejemplo, dicha función transfiere tokens.

Con el simple hecho de hacer que las funciones que tenemos en nuestro contrato cobren 1 yoctoNEAR (que es una suma extremadamente chica y no le aporta ni complica a nadie) es más que suficiente para que las wallets nos pidan que confirmemos la transacción. Por lo que es recomendable que, en la inmensa mayoría de los casos, validemos que se nos mande 1 yoctoNEAR, aunque la función no tenga costo.

## Otras utilidades
Un poco ya lo hemos utilizado, pero NEAR tiene un macro llamado `require` que nos permite validar al comienzo de la ejecución algunos requerimientos que puede tener un llamado de una función. Por ejemplo, si queremos emitir más tokens, normalmente solo el dueño del contrato o alguna cuenta que tenga el rol de operadora debería poder hacerla y no cualquier cuenta. Por esto, al comienzo de estas funciones, pondríamos una linea como `require(env::predecessor_account_id() == self.owner)` donde `env` se referirá al ambiente en el cuál se está llamando a la función y al llamar `env::predecessor_account_id()` obtendremos la cuenta que está llamando a la función. Tendremos a la vez en nuestro contrato una propiedad `owner` para poder contrastar que esta función solo sea llamada por el dueño del contrato, aunque podremos poner muchas otras condiciones de ser necesario.

Se recomienda revisar un poco la variable env y sus propiedades. Se destacan algunas otras propiedades que no mostraremos por ser suficientemente intuitivas o simples de explicar:

```
env::block_timestamp_ms
env::attached_deposit -> Un objeto con la cantidad de NEAR depositado que se puede convertir fácilmente a yocto con env::attached_deposit().as_yoctonear()
env::state_exists -> Se verá en la próxima versión
env::state_read -> Se verá en la próxima versión
env::state_write -> Se verá en la próxima versión
env::signer_account_id -> La cuenta que firmó la transacción. Dado que yo puedo llamar a un contrato y este contrato puede llamar a otro contrato, signer y predecessor pueden contener distintos valores.
```

# ¿Qué cambiaremos?
Prestenle atención a los cambios que le haremos a la función `set_greeting`. Pediremos a partir de ahora que se tenga que mandar 1 yocto para poder llamarla y que el que la llame sea la cuenta del contrato (que la dejaremos hardcodeada y en la próxima versión trabajaremos con dejar un mejor código). Verifiquen también como cambia el script de `set_greeting` para mandar el yocto

También tendremos que agregar el depósito a los tests para que funcionen y llamar con la cuenta adecuada. Para el caso del test de integración, habría que hacer muchos pasos que no suman mucho al aprendizaje, con lo que no se corregirá en esta versión y veremos con la próxima versión que se puede arreglar muy fácilmente. Este problema radica principalmente con que nosotros estamos probando deployar el contrato en testnet, con lo que las cuentas terminan en `.testnet`, mientras que los tests de integración, por defecto crean cuentas terminando en `.near` y cambiar eso, de ser posible no resulta muy instructivo.